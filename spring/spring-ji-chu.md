---
description: 从Spring的编程思想开始吧！
---

# Spring基础

## Spring的编程思想

Spring的编程思想可以总结为以下几个核心原则：

1. 依赖注入（Dependency Injection）：Spring鼓励通过依赖注入来管理组件之间的依赖关系。通过将依赖关系定义在配置文件或注解中，Spring容器负责在运行时将所需的依赖注入到组件中，解耦了组件之间的依赖关系，提高了代码的可维护性和可测试性。
2. 面向接口（Interface-based Programming）：Spring鼓励使用接口来定义组件的契约，并通过接口来编程。这样可以提高代码的灵活性和可替换性，使得组件之间更加松耦合。
3. AOP（Aspect-Oriented Programming）：Spring提供了AOP的支持，通过AOP可以将横切关注点（如日志记录、事务管理）与核心业务逻辑进行解耦。通过使用AOP，可以在不修改原有代码的情况下，将横切关注点应用到多个组件中。
4. 松散耦合（Loose Coupling）：Spring鼓励组件之间的松散耦合，通过依赖注入和面向接口编程来实现。松散耦合的设计可以提高代码的可维护性、可测试性和可扩展性。
5. 容器管理（Containerization）：Spring提供了一个IoC容器，负责管理和组织应用中的所有组件。容器通过配置文件或注解来定义和管理组件之间的依赖关系，并负责实例化、初始化和销毁组件。

通过遵循这些编程思想，开发者可以使用Spring框架构建松散耦合、可扩展和可维护的应用程序。同时，Spring还提供了丰富的功能和扩展，使得开发者可以更加高效地开发和管理应用。

## 聊一聊你对AOP的理解

AOP（面向切面编程）是一种软件开发的编程范式，旨在通过将横切关注点（如日志记录、性能统计、事务管理等）从业务逻辑中分离出来，实现对横切关注点的集中处理和重用。

在传统的面向对象编程中，我们通常通过类和对象来组织和实现系统的功能。然而，当系统的功能变得复杂时，常常会出现横跨多个对象的公共代码，比如日志记录、异常处理等。这些公共代码的散落在各个对象中，使得代码重复、可读性差，并且难以维护和修改。

AOP的核心思想是通过将这些横切关注点从业务逻辑中剥离出来，形成一个独立的切面，然后通过特定的编程技术将切面织入到系统中。在织入过程中，AOP框架会根据一些预定义的规则，将切面代码动态地插入到目标对象的特定位置，从而实现对横切关注点的统一处理。

AOP的优点在于它可以将横切关注点与业务逻辑进行解耦，提高代码的模块化和可维护性。它可以避免代码的重复编写，提高系统的可读性和可测试性，并且可以通过在运行时动态地添加或移除切面，灵活地改变系统的行为。

常见的AOP框架包括Spring AOP、AspectJ等。这些框架提供了丰富的AOP功能和机制，使得开发者能够方便地实现切面编程，并集成到现有的应用中。

总之，AOP是一种有助于解决横切关注点问题的编程范式，它通过将公共代码从业务逻辑中分离出来，提供了一种更加模块化和可维护的方式来处理系统中的横切关注点。

## Spring的AOP如何实现的

Spring的AOP（面向切面编程）是通过动态代理机制实现的。在Spring中，AOP主要通过两种方式来实现：

1. 基于代理的AOP：Spring使用动态代理技术，在运行时动态地为目标对象创建代理对象，并将切面逻辑织入到代理对象的方法中。基于代理的AOP主要有两种类型：

* 基于接口的代理：如果目标对象实现了接口，Spring将使用JDK动态代理来创建代理对象。
* 基于类的代理：如果目标对象没有实现接口，Spring将使用CGLIB库来创建代理对象，通过继承目标对象的子类来实现代理。

2. 纯POJO切面：除了基于代理的AOP，Spring还支持纯POJO切面。这种方式使用自定义的切面类，通过在切面类中定义切点和通知，来实现对目标对象的增强。Spring使用AspectJ框架来实现纯POJO切面。

无论是基于代理的AOP还是纯POJO切面，Spring都提供了一些关键的组件来支持AOP功能的实现，包括切点（Pointcut）用于定义切入点，通知（Advice）用于定义增强逻辑，以及切面（Aspect）用于将切点和通知组合在一起。

_在使用Spring的AOP时，需要进行以下几个步骤：_

1. 定义切点：确定在哪些连接点（方法或者类）上要应用切面逻辑。
2. 编写通知：定义增强逻辑，即在切点处执行的代码。
3. 创建切面：将切点和通知组合在一起，形成切面。
4. 将切面配置到Spring容器中：可以使用XML配置文件或者注解方式将切面配置到Spring容器中。
5. 在需要应用切面的地方使用被代理的对象：可以通过依赖注入或者获取代理对象的方式来使用被代理的对象。

通过上述步骤，Spring会在运行时根据配置生成代理对象，并在目标对象的方法执行前、执行后或异常时执行切面逻辑，从而实现对目标对象的增强。

需要注意的是，AOP只是Spring框架提供的一个功能，使用AOP可以实现一些横切关注点的解耦和重用，例如日志记录、事务管理等。在应用AOP时，需要合理选择切面的范围和通知的类型，避免过度使用导致复杂性增加。

## Spring AOP使用默认的代理模式

在Spring中，默认的代理模式是基于接口的代理（Interface-based proxy）。当目标对象实现了至少一个接口时，Spring将使用JDK动态代理来创建代理对象。这种代理方式要求目标对象实现接口，代理对象通过实现与目标对象相同的接口来完成代理操作。

使用基于接口的代理时，Spring会创建一个实现了目标对象接口的代理对象，并在代理对象的方法中将切面逻辑织入。当方法被调用时，代理对象会将方法的调用委托给目标对象，并在调用前后执行切面逻辑。

基于接口的代理具有一些限制，例如只能代理实现了接口的目标对象，无法代理类的非公开方法等。对于没有实现接口的目标对象，Spring会尝试使用基于类的代理（CGLIB代理）来创建代理对象。

需要注意的是，可以通过配置Spring的代理方式来指定使用基于接口的代理还是基于类的代理。通过设置`proxy-target-class`属性为`true`可以强制使用基于类的代理。默认情况下，该属性的值为`false`，即默认使用基于接口的代理。

总结起来，Spring默认使用基于接口的代理，但如果目标对象没有实现接口，Spring会自动切换到基于类的代理。

## Spring AOP在哪些情况下不能做切面？

AOP可以用于许多情况，但有一些情况下无法使用AOP来实现切面功能：

1. 私有方法：AOP只能切入公共方法，无法直接切入私有方法。这是因为AOP是通过代理对象来实现的，代理对象只能访问公共方法。
2. 静态方法：AOP无法直接切入静态方法，因为静态方法属于类级别的方法，而AOP是基于代理对象来实现的，无法通过代理对象来调用静态方法。
3. 本地方法：AOP无法切入本地方法，本地方法是指使用本地语言（如C/C++）编写的方法，无法通过Java代理对象来调用。
4. 对象内部方法调用：AOP无法切入同一个对象内部方法的调用。例如，如果一个方法A调用了同一个对象的方法B，AOP无法在A调用B的时候切入。

需要注意的是，虽然AOP在以上情况下无法直接实现切面功能，但可以通过其他手段来实现类似的效果。例如，可以使用AspectJ等工具来实现对私有方法和静态方法的切面功能。

## 聊一聊你对IOC的理解

IOC（Inversion of Control，控制反转）是一种软件设计原则，它将对象的创建、依赖关系的管理和对象的生命周期等控制权从应用程序代码转移到容器或框架中。在传统的编程模型中，应用程序代码负责创建和管理对象之间的依赖关系，而在IOC中，容器负责管理和控制对象的创建和依赖关系。

IOC的核心思想是通过将对象之间的依赖关系交给容器来管理，而不是由对象自身负责创建和管理依赖关系。通过这种方式，IOC实现了应用程序代码与对象的解耦，使得应用程序更加灵活、可维护和可测试。

在IOC的实现中，通常使用**依赖注入（Dependency Injection，DI）**的方式来管理对象的依赖关系。依赖注入是指容器在创建对象时，自动将依赖的其他对象注入到目标对象中，使得目标对象能够正常工作。依赖注入可以通过构造函数注入、属性注入或者接口注入等方式实现。

通过IOC和依赖注入，我们可以更好地管理对象之间的关系，降低对象之间的耦合度，提高代码的可测试性和可维护性。同时，IOC还可以提供其他的功能，如对象的生命周期管理、对象的配置和扩展等。

Spring框架是一个广泛应用IOC的开源框架，它通过IOC容器来管理和控制对象的创建和依赖关系。在Spring中，我们可以使用注解或XML配置来定义和配置对象，并通过IOC容器获取对象实例。Spring还提供了各种便捷的功能和扩展，如AOP、事务管理等，使得开发者能够更加方便地使用IOC的特性。

总之，IOC是一种将对象的创建和依赖关系的管理交给容器来控制的设计原则。它通过依赖注入实现对象之间的解耦，提高代码的灵活性和可维护性。Spring框架是一个广泛应用IOC的框架，它提供了强大的IOC容器和丰富的功能，帮助开发者更好地实践IOC的理念。

## 结合源码讲讲Spring的IOC实现

Spring的IOC容器的实现主要是通过`BeanFactory`和`ApplicationContext`两个核心接口来实现的。

1. `BeanFactory`接口：`BeanFactory`是Spring IOC容器的基础接口，它定义了IOC容器的基本功能，包括对象的创建、依赖注入、生命周期管理等。`BeanFactory`接口的主要实现类是`DefaultListableBeanFactory`，它使用`BeanDefinition`来描述和管理Bean的元数据信息，通过`BeanDefinition`可以指定Bean的类名、作用域、属性值等。
2. `ApplicationContext`接口：`ApplicationContext`是`BeanFactory`的子接口，它提供了更高级别的IOC容器功能，如事件发布、国际化支持、资源加载等。`ApplicationContext`接口的主要实现类是`AnnotationConfigApplicationContext`、`XmlApplicationContext`等，它们根据配置信息加载并创建IOC容器。

在IOC容器的实现中，主要包括以下几个关键步骤：

1. 加载配置信息：通过配置文件或注解等方式，将Bean的定义信息加载到IOC容器中。
2. 创建Bean实例：根据Bean的定义信息，使用反射或其他方式创建Bean的实例。
3. 依赖注入：根据Bean之间的依赖关系，将依赖的Bean注入到目标Bean中。依赖注入可以通过构造函数注入、属性注入或接口注入等方式实现。
4. 生命周期管理：在Bean的生命周期中，IOC容器会调用Bean的初始化方法和销毁方法。初始化方法可以使用`@PostConstruct`注解或实现`InitializingBean`接口来定义，销毁方法可以使用`@PreDestroy`注解或实现`DisposableBean`接口来定义。
5. Bean的后置处理：通过实现`BeanPostProcessor`接口，可以在Bean实例化和初始化过程中对Bean进行自定义处理，如AOP代理等。
6. 提供Bean的访问接口：IOC容器提供了获取Bean的方法，可以根据Bean的名称或类型来获取相应的Bean实例。

以上是IOC容器的基本实现步骤，具体的实现细节涉及到Bean的加载、依赖注入、生命周期管理等方面的逻辑。

对于源码级的讲解，可以参考Spring框架的源代码，从`BeanFactory`、`ApplicationContext`、`DefaultListableBeanFactory`等类入手，深入了解Spring IOC容器的实现细节和流程。

## Bean的生命周期

在Spring中，Bean的生命周期主要包括以下阶段：

1. 实例化：容器根据Bean的定义信息，创建Bean的实例。这可以通过构造函数实例化或工厂方法实例化来完成。
2. 属性赋值：容器将Bean的属性值注入到相应的属性中。属性赋值可以通过构造函数注入、setter方法注入或注解注入等方式实现。
3. 初始化前后处理：在Bean初始化之前和之后，容器会调用相应的回调方法或处理器对Bean进行自定义处理。可以使用`@PostConstruct`注解、`InitializingBean`接口、自定义的初始化方法等进行初始化前后的处理。
4. 初始化：容器执行Bean的初始化方法，完成Bean的初始化工作。初始化方法可以使用`@PostConstruct`注解、`InitializingBean`接口、自定义的初始化方法等来定义。
5. 使用：在容器中，Bean处于可用状态，可以被其他组件引用和使用。
6. 销毁前后处理：在容器关闭或销毁Bean时，会调用相应的回调方法或处理器对Bean进行自定义处理。可以使用`@PreDestroy`注解、`DisposableBean`接口、自定义的销毁方法等进行销毁前后的处理。
7. 销毁：容器执行Bean的销毁方法，完成Bean的资源释放和清理工作。销毁方法可以使用`@PreDestroy`注解、`DisposableBean`接口、自定义的销毁方法等来定义。

需要注意的是，Bean的生命周期由Spring容器管理，容器在创建和销毁Bean时会调用相应的回调方法或处理器。可以通过注解、接口实现等方式来定义和控制Bean的生命周期。同时，Spring也提供了扩展点，如`BeanPostProcessor`和`BeanFactoryPostProcessor`等，可以在Bean的生命周期中添加自定义的处理逻辑。

具体的Bean生命周期可以参考官方文档和源码，理解Spring框架对Bean的管理和生命周期的控制。

推荐阅读《[Spring系列第23篇：Bean生命周期详解](https://blog.csdn.net/likun557/article/details/105355394?spm=1001.2014.3001.5506)》

## BeanFactory和FactoryBean的区别

BeanFactory和FactoryBean是Spring框架中的两个核心接口，它们的作用和使用方式有所不同。

1. BeanFactory接口：

* BeanFactory是Spring的核心容器接口，它是用于管理和获取Bean对象的工厂接口。
* BeanFactory负责创建、配置和管理Bean对象的生命周期。
* BeanFactory可以从配置文件或注解中加载Bean定义，并根据需要在运行时实例化Bean对象。
* BeanFactory提供了各种方法来获取Bean对象，如根据名称、类型、别名等方式获取Bean实例。

2. FactoryBean接口：

* FactoryBean是一个特殊的Bean，它是用于创建其他Bean对象的工厂。
* FactoryBean接口定义了创建和管理特定类型Bean的方法，它可以通过实现该接口来自定义Bean的创建过程。
* FactoryBean接口的实现类负责实例化和管理其他Bean对象，并将其作为自己的一个Bean进行注册和暴露。
* 当通过容器获取FactoryBean的实例时，实际上获得的是由FactoryBean创建的Bean对象。

总结：

* BeanFactory是Spring框架的核心容器接口，负责管理和获取Bean对象。
* FactoryBean是一个特殊的Bean，用于创建和管理其他Bean对象的工厂。
* BeanFactory是Spring框架的一部分，而FactoryBean是在BeanFactory之上的一种扩展机制。

需要注意的是，当使用FactoryBean创建的Bean时，需要通过&符号来获取FactoryBean本身的实例，而不是获取FactoryBean所创建的Bean实例。

## 如何解决循环依赖的问题

Spring通过三级缓存解决了循环依赖的问题。具体解决过程如下：

1. 创建对象实例：当Spring容器初始化时，遇到需要创建的Bean对象时，会先创建一个空对象，并将其放入"Singleton Objects"缓存中。
2. 属性注入：在创建对象的过程中，如果发现有依赖其他对象的属性需要注入，会先解析依赖关系，如果依赖的对象已经在"Singleton Objects"缓存中，则直接将其注入到目标对象中；如果依赖的对象尚未创建，则先创建一个空对象并放入"Early Reference"缓存中。
3. 完成对象实例化：对象的属性注入完成后，Spring会执行对象的初始化方法，并将其标记为已创建完成。同时，将该对象从"Singleton Objects"缓存中移至"Singleton Factories"缓存中。
4. 循环依赖解决：如果发现某个对象的属性依赖又回到之前已经创建的对象上，即发生了循环依赖，Spring会通过"Object Factory"来处理。它会创建一个新的实例，同时将其放入"Singleton Objects"缓存中，以供后续的依赖注入使用。
5. 后置处理器：在对象创建完成后，Spring还会调用一些后置处理器（如BeanPostProcessor），对对象进行进一步的处理，以满足用户自定义的需求。

通过以上的解决策略，Spring能够有效地解决循环依赖的问题，并确保对象之间的依赖关系正确地注入。

## 三级缓存

实际上，Spring中没有明确称之为“三级缓存”，这是一个简化的说法，更准确的描述是基于单例对象创建过程中的缓存机制。

实际上，Spring中没有明确称之为“三级缓存”，这是一个简化的说法，更准确的描述是基于单例对象创建过程中的缓存机制。在Spring中，单例对象的创建是通过DefaultSingletonBeanRegistry类来管理的。它使用了两个缓存，分别是singletonObjects和singletonFactories。

1. singletonObjects缓存

：这个缓存用于存储已经创建完成的单例对象实例。当一个单例对象创建完成后，会被放入singletonObjects缓存中，以便后续的获取和使用。

2. singletonFactories缓存

：这个缓存用于存储正在创建过程中的单例对象的提前暴露半成品对象（Early Reference）。当一个单例对象正在创建过程中遇到循环依赖时，会先创建一个提前暴露的半成品对象，并放入singletonFactories缓存中。这个半成品对象是一个代理对象，可以暂时满足对依赖对象的引用，但其内部状态尚未完全设置。

通过使用这两个缓存，Spring能够在单例对象的创建过程中解决循环依赖的问题。当一个单例对象创建完成后，会将其放入singletonObjects缓存中，同时更新缓存中的其他相关对象的引用，以确保依赖关系正确。

这种缓存机制可以说是一种简化的描述，用于解释Spring中如何解决循环依赖的。具体的实现细节可能更为复杂，包括Bean的创建顺序、提前暴露半成品对象的处理、后置处理器的回调等。但总体思路是通过缓存来处理循环依赖，保证单例对象的正确创建和依赖注入。

### 源码解释

Spring的源码是开放的，你可以访问官方的GitHub仓库（[https://github.com/spring-projects/spring-framework）来获取源代码。](https://github.com/spring-projects/spring-framework%EF%BC%89%E6%9D%A5%E8%8E%B7%E5%8F%96%E6%BA%90%E4%BB%A3%E7%A0%81%E3%80%82)在源码中，可以查看DefaultSingletonBeanRegistry类和相关的类、接口和方法来了解循环依赖的处理过程。你可以关注以下类和方法：

1. DefaultSingletonBeanRegistry类：这个类是管理单例对象的注册表。其中包含了singletonObjects和singletonFactories两个缓存，以及处理循环依赖的逻辑。
2. getSingleton方法：这个方法是从缓存中获取或创建单例对象的关键方法。其中涉及到了缓存的使用以及循环依赖的处理。
3. getSingletonCount方法：这个方法用于获取当前已创建的单例对象的数量，可以帮助你了解缓存中的对象情况。

此外，你也可以参考Spring官方文档中对于循环依赖的解释，官方文档通常会提供详细的说明和示例。你可以访问Spring官方网站（[https://spring.io/）查找相关文档，特别是与Bean生命周期和依赖注入相关的章节。](https://spring.io/%EF%BC%89%E6%9F%A5%E6%89%BE%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3%EF%BC%8C%E7%89%B9%E5%88%AB%E6%98%AF%E4%B8%8EBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AB%A0%E8%8A%82%E3%80%82)

通过源码和官方文档的学习，你将能够更深入地了解Spring中循环依赖的解决机制。





\






\
