---
description: 从JMM开始吧！
---

# 内存模型和锁

## JMM（Java内存模型）

Java内存模型（Java Memory Model，简称JMM）是Java语言规范定义的一种抽象概念，用于描述Java程序中多线程并发访问共享内存时的行为规范和内存可见性保证。

Java内存模型的作用是确保多线程程序的正确性和可预测性。在多线程环境中，线程之间并发地读取和写入共享变量可能会导致数据不一致的问题，如竞态条件（Race Condition）、内存可见性问题等。Java内存模型通过规定了一套规范和机制，来解决这些问题。

具体来说，Java内存模型主要有以下几个作用：

1. 线程间通信：Java内存模型定义了线程之间如何进行通信和共享数据。通过合理地使用同步机制（如锁、volatile关键字、原子类等），可以确保线程之间的通信正确、有序和可见。
2. 数据可见性：Java内存模型保证了一个线程对共享变量的修改对其他线程是可见的。当一个线程修改了共享变量后，通过同步机制，其他线程可以及时看到该修改，从而避免了数据不一致的问题。
3. 顺序性保证：Java内存模型定义了一定的指令重排序规则，保证程序中的操作按照一定的顺序进行。这样可以避免由于指令重排序引起的线程间逻辑错误。
4. 原子性操作：Java内存模型保证了简单的读取和写入操作的原子性。对于基本数据类型（如int、long）、引用类型的读取和写入操作，保证了单个操作的原子性。
5. 线程安全性：Java内存模型的规范为开发者提供了编写线程安全代码的指导。通过正确使用同步机制和了解内存模型的规则，可以避免竞态条件、数据竞争等线程安全问题。

通过定义内存模型规范和使用同步机制，Java内存模型提供了一种统一的并发编程模型，使得开发者能够编写线程安全的代码。

## Volatile关键字

`volatile` 是Java中的一个关键字，用于声明变量，表示该变量是共享的，多个线程之间对该变量的读写具有可见性。

### `volatile` 的作用

1. 可见性：当一个线程修改了 `volatile` 变量的值，其他线程能够立即看到最新的值。这是因为 `volatile` 变量的修改会立即刷新到主内存，并使其他线程的工作内存中的缓存失效，强制从主内存中重新读取最新值。
2. 禁止重排序：`volatile` 变量的读写具有禁止重排序的效果，保证了对该变量的操作按照代码的顺序执行。

需要注意的是，`volatile` 关键字并不能保证原子性。对于复合操作（例如自增、自减）或者需要保持原子性的操作，仍然需要使用其他的同步机制（如锁或原子类）来保证线程安全。

#### 可见性和禁止指令重排序的实现

`volatile` 关键字确实通过使用内存屏障（Memory Barrier）来保证变量的可见性，但是它并不能完全禁止重排序。事实上，`volatile` 主要用于保证可见性，而对于有序性（禁止重排序）的保证是间接的。

具体来说，`volatile` 关键字在写操作和读操作的两个关键点上使用内存屏障：

1. Load Barrier（读屏障）：在读取 `volatile` 变量之前会插入读屏障。读屏障的作用是确保在读取 `volatile` 变量之前，先读取其他变量的最新值，避免使用过期的缓存值。读屏障可以防止指令重排序，保证了读操作的顺序性和可见性。
2. Store Barrier（写屏障）：在写入 `volatile` 变量之后会插入写屏障。写屏障的作用是确保在写入 `volatile` 变量之后，将修改后的值立即刷新到主内存，而不是延迟刷新。写屏障可以防止指令重排序，保证了写操作的顺序性和可见性。

这两个内存屏障的作用是保证了对 `volatile` 变量的读写操作具有以下特性：

1. 可见性：当一个线程写入 `volatile` 变量时，会立即刷新到主内存，其他线程在读取该变量时会从主内存中获取最新的值，而不是使用本地缓存中的旧值。
2. 部分有序性：`volatile` 关键字保证了写操作先行发生于后续的读操作，即写操作与读操作之间的顺序关系得到保证。

需要注意的是，`volatile` 关键字不能完全禁止指令重排序，因为它只对 `volatile` 变量的读写操作提供了部分有序性的保证。如果需要更强的有序性保证，可以使用锁或其他同步机制，如`synchronized`关键字或`java.util.concurrent`包中的锁类。

## Java锁类型

美团的这篇文章对Java锁的介绍非常全面：《[不可不说的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html)》

## Java对象锁的结构在什么地方

Java对象的锁结构存储在对象的对象头（Object Header）中。对象头是对象在内存中的一部分，用于存储对象的元数据信息和同步状态。在32位的JVM中，对象头通常占据8个字节的空间，而在64位的JVM中，对象头通常占据12或16个字节的空间。

对象头中包含了对象的标记信息、类型指针以及锁相关的信息。其中，锁相关的信息用于支持Java中的同步机制，主要有以下两种形式的锁结构：

1. 普通锁（Mark Word）：

* 普通锁是对象头中的一部分，用于实现对象级别的同步。
* 它通常包含锁的状态、持有锁的线程ID、锁的重入次数等信息。
* 当一个线程获取到对象的锁时，它会修改普通锁的状态，标识该对象被当前线程所持有。

2. 重量级锁（Fat Lock）：

* 重量级锁是一种特殊的锁结构，用于支持多线程之间的同步。
* 当多个线程争夺同一个对象的锁时，JVM会将普通锁升级为重量级锁。
* 重量级锁会在对象头之外额外分配一块空间，用于存储锁的互斥信号量、线程等待队列等信息。

需要注意的是，锁结构的具体实现可能会因不同的JVM实现而有所差异。例如，HotSpot JVM中的锁结构包括偏向锁、轻量级锁和重量级锁，它们的使用和转换过程是根据对象的竞争情况动态调整的。

锁结构的存在使得Java中的同步机制成为可能，通过锁机制可以保证多线程之间的安全性和顺序性。然而，在编写多线程程序时，需要注意正确使用锁，避免死锁、竞争条件等问题，以保证程序的正确性和性能。

## 锁升级的过程

锁升级是指在多线程环境中，锁的状态从低级别的状态逐渐升级为高级别的状态，以提高并发性能。Java 中的锁升级过程主要涉及到三个级别的锁：偏向锁、轻量级锁和重量级锁。

1. 偏向锁（Biased Locking）：偏向锁是为了解决多线程竞争情况下的性能问题而引入的机制。在偏向锁状态下，锁会偏向于第一个获取它的线程，当只有一个线程访问同步块时，这个线程可以获取锁而无需进行同步操作。如果其他线程尝试获取该锁，会撤销偏向锁状态，升级为轻量级锁。
2. 轻量级锁（Lightweight Locking）：当多个线程竞争同一个锁时，会出现轻量级锁状态。在轻量级锁状态下，锁不再偏向于任何一个特定的线程，而是通过CAS（Compare and Swap）操作来尝试获取锁。如果竞争失败，线程会将锁升级为重量级锁。
3. 重量级锁（Heavyweight Locking）：当轻量级锁竞争失败时，锁会升级为重量级锁。重量级锁使用操作系统提供的互斥量来实现，它会涉及线程的阻塞和唤醒操作，较为耗费系统资源。

锁升级的过程是自动进行的，由虚拟机根据竞争情况和线程的行为自动切换锁的状态。具体的锁升级过程如下：

1. 偏向锁升级：当有多个线程尝试获取偏向锁时，偏向锁会撤销，升级为轻量级锁。
2. 轻量级锁升级：当一个线程自旋获取轻量级锁的次数超过一定的阈值，或者锁竞争的线程数超过一定的阈值，轻量级锁会膨胀为重量级锁。
3. 重量级锁降级：当持有重量级锁的线程释放锁时，锁会降级为无锁状态，这是为了避免后续的锁竞争。

锁升级的目标是尽量减少锁的竞争和降低系统开销。通过逐级升级锁的状态，可以在并发环境中提供不同程度的性能优化，以适应不同的线程竞争情况。

## 锁消除和锁粗化

锁消除（Lock Elimination）和锁粗化（Lock Coarsening）是优化技术，用于提高多线程程序的性能和效率。

1. 锁消除：锁消除是指在编译器优化阶段，根据代码分析和上下文信息，判断某些锁是不需要的，并且可以安全地消除它们。当编译器确定某些锁在特定的代码路径上不会产生竞争条件时，它可以消除对应的锁操作，从而避免了不必要的同步开销。

锁消除通常发生在以下情况下：

* 当编译器确定某个对象在整个方法执行过程中只有一个线程访问时，可以消除该对象上的锁操作。
* 当编译器确定某个对象已经不可能被其他线程访问时，可以消除该对象上的锁操作。

2. 锁粗化：锁粗化是指在编译器优化阶段，将多个连续的细粒度锁操作合并为一个粗粒度的锁操作。当编译器发现某个代码块中存在多次连续的锁操作，且这些锁操作之间没有其他的共享变量访问或其他干扰因素时，它可以将这些锁操作合并为一个更大的锁范围，从而减少锁操作的次数。

锁粗化的目的是减少锁竞争和同步开销，避免频繁地获取和释放锁。将多个细粒度的锁操作合并为一个粗粒度的锁操作可以提高程序的性能。需要注意的是，锁消除和锁粗化都是编译器层面的优化技术，由编译器自动进行优化。开发人员可以通过编写高效的代码结构和减少不必要的锁使用，以帮助编译器更好地进行锁消除和锁粗化优化

## 从字节码的层面来解释synchronized的实现原理

从字节码的角度来解释 `synchronized` 的实现原理，可以关注两个关键字：`monitorenter` 和 `monitorexit`。

1. `monitorenter`：`monitorenter` 是一个字节码指令，用于获取对象的监视器锁。当线程遇到 `synchronized` 修饰的方法或代码块时，字节码中会插入 `monitorenter` 指令来获取锁。如果锁是空闲的，线程会成功获取锁并继续执行后续的指令；如果锁被其他线程持有，线程将进入阻塞状态，等待锁的释放。
2. `monitorexit`：`monitorexit` 是一个字节码指令，用于释放对象的监视器锁。当线程执行完 `synchronized` 修饰的方法或代码块时，字节码中会插入 `monitorexit` 指令来释放锁。这样，其他等待该锁的线程可以有机会获取锁并执行相应的代码。

在字节码层面，`synchronized` 的实现可以简化为以下过程：

1. 进入监视器：遇到 `synchronized` 关键字时，执行 `monitorenter` 指令，尝试获取对象的监视器锁。
2. 执行同步代码：获取到锁之后，线程进入临界区，执行 `synchronized` 修饰的方法或代码块。
3. 退出监视器：执行完 `synchronized` 修饰的方法或代码块后，执行 `monitorexit` 指令，释放对象的监视器锁。

需要注意的是，字节码层面的指令只是描述了 `synchronized` 的基本实现原理，并不涉及具体的锁优化和锁粒度等细节。虚拟机在执行字节码时会根据具体的实现策略进行优化，以提高并发性能。

## synchronized的可重入是如何实现的

synchronized的可重入（Reentrant）是通过线程持有锁的计数器来实现的。

当一个线程进入一个synchronized代码块时，它会尝试获取锁。如果锁是自由的（没有被其他线程持有），那么该线程会成功获取锁，并将锁的计数器设置为1。在此过程中，线程会将自己的线程ID保存在锁的持有者字段中。&#x20;

如果同一个线程再次进入同一个synchronized代码块，它仍然可以获取到锁。这时，锁的计数器会递增，表示该线程重入了多少次。每一次重入，计数器都会递增，每一次退出，计数器都会递减。只有当计数器归零时，锁才会被释放，其他线程才有机会获取锁。&#x20;

通过锁的计数器，synchronized实现了可重入的效果。同一个线程可以多次获取同一个锁，而不会被阻塞。这种机制确保了在递归调用或者嵌套的synchronized代码块中，线程可以正常地进行操作，而不会出现死锁或者无法获取锁的情况。

可重入的特性是由synchronized关键字在底层实现中自动支持的，不需要额外的代码或者手动操作。这种机制使得编写和理解嵌套的同步代码更加简单和直观，并提高了代码的可读性和可维护性。

## synchronized静态方法和普通方法锁的对象是什么

当一个线程进入一个静态同步方法时，它会尝试获取该方法所属的Class对象的锁。&#x20;

一个线程进入一个实例同步方法时，它会尝试获取该方法所属对象的锁。&#x20;

静态方法的锁作用范围是类级别的，而实例方法的锁作用范围是实例级别的。

## synchronized 和 volatile 比较

`synchronized` 和 `volatile` 是 Java 中用于实现多线程编程的关键字，它们在功能和使用方式上有一些区别：

1. 功能不同：

* `synchronized` 用于实现线程之间的互斥同步，确保同一时间只有一个线程可以进入 `synchronized` 修饰的代码块或方法。
* `volatile` 用于实现变量的可见性和禁止重排序，保证多个线程之间对于该变量的读写操作是正确的。

2. 适用范围不同：

* `synchronized` 可以修饰方法、代码块和静态方法，适用于任意的同步需求。它可以实现更复杂的线程同步机制，如互斥锁和条件等待。
* `volatile` 只能修饰变量，适用于简单的变量同步场景，用于保证变量的可见性和禁止指令重排序。

3. 锁粒度不同：

* `synchronized` 可以提供更细粒度的锁控制，可以在代码块级别或方法级别进行同步。这样可以避免不必要的锁竞争，提高并发性能。
* `volatile` 并不提供锁的机制，它仅保证变量的可见性和禁止重排序，无法实现复杂的线程同步和互斥控制。

4. 保证顺序不同：

* `synchronized` 在释放锁之前，会将修改过的共享变量立即刷新到主内存，从而保证了变量的可见性和顺序性。
* `volatile` 在每次读取变量和写入变量时，都会直接操作主内存，而不是从线程的工作内存中读取或写入。这样可以保证变量的可见性和顺序性。

需要注意的是，虽然 `volatile` 可以保证变量的可见性，但它并不能替代 `synchronized` 在复杂同步场景中的功能。在需要实现原子性操作、条件等待和复合操作时，仍然需要使用 `synchronized` 或其他更高级的同步机制。

## ReentrantLock

美团的这篇文章对ReentrantLock的介绍非常全面：《[从ReentrantLock的实现看AQS的原理及应用](https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html)》

## AQS的实现原理

AQS（AbstractQueuedSynchronizer）是 Java 并发包中提供的一个抽象类，用于实现基于锁的同步器。它是许多同步类（如 ReentrantLock、CountDownLatch、Semaphore 等）的基础。

AQS 的实现原理主要基于一个等待队列（wait queue）和一个同步状态（synchronization state）。

AQS 的实现原理如下：

1. 等待队列：AQS 使用一个 FIFO 队列来保存等待获取同步资源的线程。这个队列的每个节点都表示一个等待线程，并维护了一些状态信息，如等待状态和等待条件等。
2. 同步状态：AQS 内部维护了一个同步状态（synchronization state）的变量，用于表示共享资源的状态或控制资源的访问。
3. acquire 方法：当线程调用 `acquire` 方法尝试获取同步资源时，AQS 首先会通过 CAS 操作来尝试获取同步状态。如果获取成功，则线程可以继续执行；如果获取失败，则线程会被加入到等待队列中，并进入阻塞状态。
4. release 方法：当线程调用 `release` 方法释放同步资源时，AQS 会更新同步状态，并通过唤醒机制从等待队列中选择一个或多个等待线程进行唤醒。
5. 入队和出队操作：线程在尝试获取同步资源时，如果获取失败，会被加入到等待队列中，通过 `LockSupport.park()` 进入阻塞状态。当同步资源可用时，被阻塞的线程会被唤醒，然后从等待队列中出队，重新尝试获取同步资源。
6. 条件变量：AQS 还支持条件变量的功能，即支持 `await` 和 `signal` 方法的使用。等待队列中的节点可以被分为多个条件队列，每个条件队列都与一个特定的条件相关联。线程可以通过条件队列进入等待状态，并在满足特定条件时被唤醒。

通过以上机制，AQS 实现了多线程间的同步和互斥，控制了对共享资源的访问，以及提供了条件变量的功能。AQS 的设计为其他同步器的实现提供了基础，简化了同步器的开发和扩展。

**一句话总结：AQS使用一个被volatile修饰的int类型的成员变量state来表示同步状态，通过内置的FIFO等待队列来管理获取资源时加锁失败的线程，通过CAS完成对state值的修改。**

## synchronized 和 ReentrantLock 比较 <a href="#synchronized-he-reentrantlock-you-shen-me-qu-bie" id="synchronized-he-reentrantlock-you-shen-me-qu-bie"></a>

`synchronized` 和 `ReentrantLock` 是 Java 中常用的两种实现锁的机制，它们有以下比较：

1. 可重入性：
   * `synchronized`：支持可重入性，同一个线程可以多次获取同一个锁，避免死锁情况。
   * `ReentrantLock`：同样支持可重入性，允许线程多次获取同一个锁。
2. 锁的获取方式：
   * `synchronized`：隐式获取锁，无需手动获取和释放锁，JVM 自动管理。
   * `ReentrantLock`：需要显式地调用 `lock()` 方法获取锁，且必须在适当的时候调用 `unlock()` 方法释放锁。
3. 锁的公平性：
   * `synchronized`：非公平锁，无法保证线程获取锁的顺序。
   * `ReentrantLock`：可选择公平锁或非公平锁，公平锁会按照线程的请求顺序分配锁，非公平锁允许线程插队获取锁。
4. 性能：
   * `synchronized`：JVM 对 `synchronized` 进行了优化，性能较高，在低竞争情况下效果良好。
   * `ReentrantLock`：相对于 `synchronized`，`ReentrantLock` 的性能更好，在高竞争情况下效果更佳。
5. 锁的灵活性：
   * `synchronized`：用于修饰方法或代码块，灵活性较低。
   * `ReentrantLock`：可以灵活地定制锁的行为，提供了一些高级特性，如可中断锁、超时获取锁、多个条件变量等。

总体来说，`synchronized` 是一种更简单和常用的锁机制，适用于大多数情况下的并发控制。而 `ReentrantLock` 提供了更多的灵活性和高级特性，适用于一些特殊的并发场景，如需要精确控制锁的获取和释放、需要公平性、需要可中断等。在性能要求较高或特殊需求的情况下，可以考虑使用 `ReentrantLock`。



\












