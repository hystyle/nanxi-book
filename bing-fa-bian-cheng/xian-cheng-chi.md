---
description: 从Java线程池的实现原理开始吧！
---

# 线程池

## Java线程池的实现原理

美团的这篇文章对Java线程池的介绍非常全面《[Java线程池实现原理及其在美团业务中的实践](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)》

## ThreadPoolExecutor的主要设置参数有哪些?

ThreadPoolExecutor的主要设置参数有以下几个：

1. corePoolSize:核心线程数，即使这些线程处于空闲状态，它们也不会被销毁，除非设置了allowCoreThreadTimeOut。当线程数小于corePoolSize时，即使有线程空闲，线程池也会优先创建新线程处理。
2. maximumPoolSize:最大线程数。当线程数 >= corePoolSize,且任务队列已满时，线程池会创建新线程来处理任务。当线程数 = maxPoolSize,且任务队列已满时，线程池会拒绝处理任务而抛出异常。
3. keepAliveTime:空闲线程的存活时间。当空闲线程的存活时间大于0时，如果当前线程池中的线程数量超过corePoolSize,且空闲时间超过keepAliveTime时，则会回收空闲线程。
4. unit:keepAliveTime的时间单位。
5. workQueue:任务队列。它是一个阻塞队列，用于存储等待执行的任务。
6. threadFactory:用于创建新线程的工厂类。
7. handler:拒绝策略。当任务无法提交给线程池时，handler会处理该任务。

## 线程池参数设计会根据什么因素考量

线程池参数设计通常会考虑以下几个因素：

1. 任务类型和特性：需要考虑线程池中执行的任务类型，例如CPU密集型任务、IO密集型任务、长时间任务等。不同类型的任务对线程池的参数需求不同。例如，对于IO密集型任务，可能需要更多的线程数以充分利用CPU等待时间；而对于CPU密集型任务，可能需要较少的线程数以避免线程切换开销。
2. 可用的硬件资源：线程池的参数还应考虑系统可用的硬件资源，如CPU核心数、内存大小等。合理设置线程池的线程数可以充分利用硬件资源，避免资源浪费或过度竞争。
3. 任务数量和负载：预估任务的数量和负载情况，根据实际情况调整线程池的大小。如果任务量较大，可以增加线程数以提高并发性能；如果任务量较小，可以减少线程数以节省资源。
4. 响应时间要求：根据任务的响应时间要求，调整线程池的大小和任务队列的容量。如果任务需要快速响应，可以增加线程数以减少等待时间；如果响应时间要求较宽松，可以适当减少线程数以节省资源。
5. 系统稳定性：考虑系统的稳定性和资源管理。设置合适的线程数和任务队列大小，以避免系统资源耗尽、任务阻塞或者系统崩溃的情况发生。

## 在自定义线程池时，如何选择阻塞队列？请结合具体场景说说

选择适当的阻塞队列类型对自定义线程池的性能和行为有重要影响。不同的阻塞队列适用于不同的场景。以下是几种常见的阻塞队列类型及其适用场景：

1. **ArrayBlockingQueue**：这是一个基于数组的有界阻塞队列。适用于固定大小的线程池，适合于任务数不会太多的情况，因为当队列已满时，新的任务将会被阻塞，保证了队列大小的控制。
2. **LinkedBlockingQueue**：这是一个基于链表的无界阻塞队列。适用于任务数较多的情况，可以根据需要自动扩展队列大小。然而，如果不控制添加任务的速度，可能会导致内存耗尽。
3. **PriorityBlockingQueue**：这是一个基于优先级的阻塞队列。适用于需要根据优先级处理任务的场景，队列中的元素会按照优先级排序。
4. **SynchronousQueue**：这是一个不存储元素的阻塞队列，每个插入操作必须等待一个相应的删除操作，适用于一些线程间交换数据的场景。
5. **DelayQueue**：这是一个支持延迟执行的阻塞队列，适用于需要延迟执行任务的场景，任务会在指定的延迟时间之后被取出。

具体选择哪种阻塞队列类型取决于你的业务需求和线程池的性能要求。如果你需要控制队列大小，可以选择有界队列；如果需要支持优先级，可以选择优先级队列；如果需要支持延迟执行，可以选择延迟队列。

举例来说，如果你的线程池用于处理网络请求，而且预期请求的数量可能会比较大，但是你希望保证系统不会因为过多的请求导致内存耗尽，你可以选择使用 LinkedBlockingQueue，因为它是无界的，可以根据需要动态调整队列大小，但需要注意控制请求的速度。如果你的线程池用于处理定时任务，你可以考虑使用 DelayQueue 来支持延迟执行。

总之，选择适当的阻塞队列类型需要综合考虑业务需求和系统性能，确保线程池在各种情况下都能稳定高效地运行。

## Java中默认实现好的线程池

1. `Executors.newFixedThreadPool(int nThreads)`: 创建一个固定大小的线程池，该线程池中的线程数量固定为指定的数量 `nThreads`。适用于处理较长时间的任务，保持线程数量稳定，避免线程的创建和销毁带来的开销。
2. `Executors.newCachedThreadPool()`: 创建一个缓存的线程池，该线程池会根据需要自动创建新的线程，如果有空闲线程，则会重用空闲线程，如果没有可用线程，则会创建新的线程。适用于大量短期任务的场景，可以根据需求动态调整线程数量。
3. `Executors.newSingleThreadExecutor()`: 创建一个单线程的线程池，该线程池中只有一个工作线程，适用于需要顺序执行任务的场景，保证任务按照提交的顺序依次执行。
4. `Executors.newScheduledThreadPool(int corePoolSize)`: 创建一个定时任务的线程池，该线程池可以按照一定的延迟或固定的周期执行任务。可以用于定时执行任务或周期性执行任务的场景。

这些线程池都是通过 `ThreadPoolExecutor` 类进行实现的，提供了方便的线程管理和任务调度功能。

