---
description: 从认识索引开始吧！
---

# 索引

## 索引介绍

**索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。**

## 索引的优缺点

**优点**：

* 使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。
* 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

**缺点**：

* 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。
* 索引需要使用物理文件存储，也会耗费一定空间。

但是，**使用索引一定能提高查询性能吗?**

大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。

## 聚簇索引与非聚簇索引 <a href="#ju-cu-suo-yin-yu-fei-ju-cu-suo-yin" id="ju-cu-suo-yin-yu-fei-ju-cu-suo-yin"></a>

聚簇索引：聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。

非聚簇索引：非聚簇索引(Non-Clustered Index)即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。

## 索引下推

索引下推（Index Condition Pushdown，简称ICP）是一种优化技术，用于提高查询性能和减少不必要的数据访问。它在MySQL数据库中被广泛使用。

索引下推就是指在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数来提高查询效率。

具体来说，索引下推的过程如下：

1. 查询解析：数据库解析查询语句，并确定使用的索引。
2. 索引扫描：数据库使用索引定位到符合查询条件的索引记录。
3. 条件下推：在扫描索引的同时，数据库将查询条件下推给存储引擎，由存储引擎对索引记录进行条件过滤。
4. 返回结果：存储引擎返回满足查询条件的索引记录给数据库。

通过索引下推，数据库在读取索引的过程中就可以进行条件过滤，只返回满足条件的数据行，减少了不必要的数据访问和内存消耗。

索引下推（mysql5.6之后）：建立一个联合索引，如idx\_name\_age，查询时sql语句使用like “%name” and age = 1; 没有使用索引下推前，先在索引树中通过name范围查询，比如查询出有4条，则需要回表四次去匹配age=1的行数据，这样会浪费联合索引中的另一个字段age；使用索引下推，搜索时会直接在联合索引中按照age=1进行过滤，然后再进行回表扫描，减少了树的搜索次数，提高了访问效率。

## 索引回表

索引回表（Index Lookup）是在数据库查询过程中的一种常见操作。当一个查询包含非索引列的查询需求时，数据库需要通过索引回表来获取这些额外的数据列。

通常，数据库的索引结构只包含了索引列及其对应的引用（如行ID或主键），而非索引列的数据存储在数据页中。当查询需要访问这些非索引列时，数据库就需要进行索引回表操作。、

索引回表的过程如下：

1. 根据查询条件使用索引定位到符合条件的索引记录。
2. 根据索引记录中的引用（如行ID或主键）找到对应的数据页。
3. 从数据页中读取非索引列的数据。
4. 返回结果给查询。

索引回表操作会引入额外的I/O操作和内存访问，因为数据库需要从数据页中读取额外的数据列。这会增加查询的开销，特别是在查询结果集较大或需要读取多个非索引列时。

为了减少索引回表的开销，一种常见的优化策略是使用覆盖索引（Covering Index）。覆盖索引是一种包含了查询所需的全部数据列的索引。通过使用覆盖索引，数据库可以直接从索引中获取所有查询所需的数据，避免了索引回表操作，提高了查询性能。

需要根据具体的查询需求和数据模型来评估是否使用覆盖索引以及其他索引优化策略。通过合理设计索引和查询语句的编写，可以最大限度地减少索引回表操作，提高查询效率。

基于普通索引查询需要多扫描一颗索引树。例如，在存在主键索引的情况下，我们以name为索引字段创建了一个普通索引，普通索引的叶子节点存储的是主键值，查询时，我们需要先通过普通索引查询到主键值，再通过主键索引查找到具体的数据行。这就是所谓的回表。

## 覆盖索引

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 **覆盖索引（Covering Index）。**

通过索引树直接返回SQL所需的列数据，无需回表。

## 索引失效的情况

索引在某些情况下可能会失效，导致查询性能下降。以下是一些导致索引失效的常见情况：

1. 不使用索引列进行查询：如果查询条件不涉及到索引列，数据库可能会选择全表扫描而不使用索引。在这种情况下，索引失去了作用。
2. 对索引列进行函数操作：如果在查询中对索引列进行函数操作，如使用函数、类型转换或计算表达式，数据库可能无法使用索引进行优化，而是进行全表扫描。
3. 使用"NOT"运算符：使用"NOT"运算符对索引列进行否定操作，或者使用"<>", "!="等不等号操作符，可能导致索引失效。
4. 数据列上的隐式类型转换：如果查询条件中的值与索引列的数据类型不匹配，数据库可能会进行隐式类型转换，这会导致索引失效。
5. 统计信息不准确：数据库依赖于统计信息来优化查询计划。如果统计信息过期或不准确，数据库可能会做出错误的优化决策，导致索引失效。
6. 索引选择不当：索引的选择和设计是一个重要的因素。如果索引选择不当，如创建了过多或不必要的索引，或者索引列不符合查询模式，那么索引可能无法被有效利用。
7. 数据更新频繁：当表中的数据频繁进行插入、更新和删除操作时，索引可能会失效。这是因为数据库需要维护索引的一致性，而频繁的数据更新可能导致索引失去优化效果。

为避免索引失效，需要合理设计和选择索引，保证统计信息的准确性，避免在查询条件中对索引列进行函数操作，并确保查询中使用了正确的操作符和数据类型。此外，定期检查索引的使用情况和性能，进行必要的索引优化和调整也是重要的措施。

## 隐式转换说明

当查询条件中的值与索引列的数据类型不匹配时，会导致索引失效。以下是一个示例：

假设有一个名为"users"的表，其中有一个索引列"age"表示用户的年龄。如果"age"列的数据类型为整数（Integer），但是在查询时使用了字符串类型的值作为条件，如下所示：

```sql
SELECT * FROM users WHERE age = '25';
```

由于查询条件中的值是一个字符串，而索引列的数据类型是整数，数据库无法直接使用索引进行匹配，而是需要进行隐式类型转换。这种情况下，数据库可能会放弃使用索引，而选择执行全表扫描，从而导致索引失效。

为避免这种情况，应确保查询条件中的值与索引列的数据类型匹配。如果要使用索引，应使用相同的数据类型进行查询，即：

```sql
SELECT * FROM users WHERE age = 25;
```

这样数据库可以直接利用索引进行匹配，提高查询性能。

## 索引失效的案例

在 SQL 查询中，有一些具体的写法或函数使用会对索引的使用产生影响，可能导致索引失效或无法被有效利用。以下是一些常见的情况：

1. 对索引列进行函数操作：如果在查询条件中对索引列进行函数操作，如使用函数、类型转换或计算表达式，数据库可能无法使用索引进行优化，而是进行全表扫描。

```sql
例子：对索引列进行函数操作
SELECT * FROM users WHERE UPPER(name) = 'JOHN';
```

2. 使用"NOT"运算符：使用"NOT"运算符对索引列进行否定操作，或者使用"<>", "!="等不等号操作符，可能导致索引失效。

```sql
-- 例子：使用"NOT"运算符
SELECT * FROM users WHERE NOT age = 30;

-- 例子：使用不等号操作符
SELECT * FROM users WHERE age <> 30;

```

3. 字符串模糊匹配操作：如果在查询中使用通配符（如%）开头的字符串模糊匹配，索引可能无法被利用。

```sql
-- 例子：字符串模糊匹配
SELECT * FROM users WHERE name LIKE '%John';
```

4. 组合索引顺序不一致：如果创建了复合索引，索引列的顺序应与查询条件中的顺序一致，以保证索引被正确利用。

```sql
-- 例子：复合索引的顺序不一致
CREATE INDEX idx_name_age ON users (name, age);

-- 查询条件中的顺序与索引不一致，可能导致索引失效
SELECT * FROM users WHERE age = 30 AND name = 'John';
```

5. 数据类型不匹配：如前面所提到的，如果查询条件中的值与索引列的数据类型不匹配，索引可能无法被有效利用。

这些情况下，数据库可能会选择执行全表扫描或其他方式来处理查询，而不是使用索引。因此，在编写 SQL 查询时，应避免以上情况，确保查询可以充分利用索引，提高查询性能。

## or和in关键字是否会用到索引

都可以，但是具体条件具体分析。

在一般情况下，OR 和 IN 这两个操作符可能会对索引的使用产生一些影响。

1. OR 操作符：OR 操作符用于连接多个条件，当其中至少一个条件使用了索引时，数据库可能会使用索引来优化查询。然而，当 OR 操作符连接的条件中既有使用索引的条件，又有不使用索引的条件时，数据库可能无法有效地利用索引进行查询优化，而是需要执行全表扫描来获取结果。
2. IN 操作符：IN 操作符用于指定一个值的集合，数据库可以使用索引来快速定位这些值。当 IN 的值集合较小并且索引列是一个单列索引时，数据库通常可以有效地使用索引来加速查询。然而，当 IN 的值集合较大或者索引列是一个复合索引时，数据库可能无法高效地使用索引，导致性能下降。

需要注意的是，优化器会根据查询的具体情况和数据统计信息来决定是否使用索引。有时候，即使查询条件中包含了 OR 或 IN 操作符，数据库仍然可以通过其他优化策略来使用索引。另外，通过适当的索引设计和查询重写，可以提高 OR 和 IN 操作符在使用索引方面的性能。

总而言之，OR 和 IN 操作符对索引的使用效果取决于具体的查询语句、索引设计和数据分布等因素。在实际应用中，可以通过观察执行计划、性能测试和优化查询语句等方式来评估并优化索引的使用效果。

### 举例说明

当使用 OR 和 IN 操作符时，是否使用索引的情况可以通过以下示例来说明：

1. OR 操作符的示例：&#x20;

假设有一个包含了 name 和 age 两个列的表，其中有一个索引在 name 列上。考虑以下查询语句：

```sql
SELECT * FROM table_name WHERE name = 'John' OR age = 30;
```

如果数据库选择使用索引来优化查询，它可以使用 name 列上的索引来定位 'John' 相关的行。然而，对于 age = 30 的条件，如果没有单独的索引或统计信息表明 age 列的选择性很高，数据库可能会选择执行全表扫描来获取满足条件的行。

2. IN 操作符的示例：

假设有一个包含了 category 和 price 两个列的表，其中有一个复合索引在 (category, price) 列上。考虑以下查询语句：

```sql
SELECT * FROM table_name WHERE category IN ('Electronics', 'Books') AND price > 100;
```

如果数据分布均匀且统计信息表明 category 列的选择性很高，数据库可以使用索引来定位 'Electronics' 和 'Books' 相关的行。然而，对于 price > 100 的条件，因为这个条件无法直接使用复合索引进行匹配，数据库可能无法高效地使用索引，而是选择全表扫描来获取满足条件的行。

需要注意的是，具体的索引使用策略和效果取决于数据库的优化器和查询统计信息，不同的数据库系统可能有不同的行为。以上示例仅为演示用途，实际情况可能因数据分布、索引设计和查询语句的复杂性而有所不同。在实际应用中，通过观察执行计划和性能测试，可以更好地了解 OR 和 IN 操作符在使用索引方面的效果。

## 关于范围查询是否使用到索引

范围查询在某些情况下可能使用索引，但在其他情况下可能无法使用索引。

对于一般的 B-Tree 索引，范围查询可以有效地使用索引，例如：

```sql
SELECT * FROM table_name WHERE age > 20 AND age < 30;
```

如果 age 列上存在索引，数据库可以使用索引的 B-Tree 结构进行范围扫描，找到满足条件的行。

然而，对于某些特殊情况，范围查询可能无法使用索引或效果较差，例如：

* 当范围查询涉及到索引列的开头部分，而不是索引列的精确匹配。例如：

```
SELECT * FROM table_name WHERE name LIKE 'John%';
```

这种情况下，如果 name 列上存在索引，索引可能会被用于匹配开头的 'John'，但随后需要执行全表扫描来获取满足条件的行。

* 当范围查询涉及到复合索引的后续列。例如：

```sql
SELECT * FROM table_name WHERE category = 'Electronics' AND price > 100;
```

如果 (category, price) 是一个复合索引，数据库可以使用索引定位到 'Electronics' 相关的行，但无法直接使用索引进行 price > 100 的筛选，可能需要进一步的条件判断或全表扫描来满足查询需求。

综上所述，范围查询在某些情况下可以使用索引，但在特定的条件下可能无法直接使用索引或效果不佳。因此，在设计索引和编写查询语句时，需要综合考虑数据分布、查询需求和索引结构，以获得最佳的性能。如果范围查询的性能不尽如人意，可能需要进一步优化索引或查询方式。

## 多路平衡二叉树（B树）和加强版的多路平衡二叉树（B+树）的区别?

* B+树的非叶子节点只保存关键字以及对子节点的引用
* B+树的叶子节点保存了关键字对应的具体数据，并且，叶子节点之间是顺序排列的，相邻节点之间存在顺序引用的关系。

## 最左匹配原则

比如创建联合索引：name\_age, like "王%" and age =17 , 每个非叶子节点是name\_age，首先会先按照索引name查询出一个范围，然后才会去定位age在哪

## 执行计划

执行计划可以帮助我们查看sql执行的信息。索引可以加快数据库的查询速度。mysql数据库的索引采用的是B+ tree数据结构

使用执行计划：

type:本次查询表联接类型，从这里可以看到本次查询大概的效率

key:最终选择的索引，如果没有索引的话，本次查询效率通常很差

key\_len:本次查询用于结果过滤的索引实际长度

ows:预计需要扫描的记录数，预计需要扫描的记录数越小越好

Extra:额外附加信息，主要确认是否出现 Using filesort、Using temporary 这两种情况

