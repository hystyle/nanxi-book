---
description: 从Java语言的特点开始吧！
---

# 核心技术总结

## Java语言有哪些特点？

\
Java语言具有以下特点：

1. 简单易学：Java语言设计简洁，语法类似于C++，但去除了一些复杂和容易出错的特性，使得学习和使用相对容易。
2. 面向对象：Java是一种面向对象的编程语言，支持封装、继承和多态等面向对象的概念，使得代码更加模块化、可复用和易于维护。
3. 平台无关性：Java通过虚拟机（Java Virtual Machine，JVM）实现了平台无关性，可以在不同操作系统上运行。编写的Java代码可以在任何支持Java虚拟机的平台上运行，提高了可移植性。
4. 内存管理：Java提供了自动的内存管理机制，即垃圾回收（Garbage Collection），可以自动管理对象的分配和释放，减轻了开发人员对内存管理的负担。
5. 强类型检查：Java是一种静态类型语言，要求变量在使用之前必须声明其类型，并在编译时进行类型检查，提前发现错误，减少潜在的运行时错误。
6. 异常处理：Java提供了强大的异常处理机制，可以捕获和处理运行时异常，避免程序的崩溃，并提供了可靠的错误处理方式。
7. 多线程支持：Java内置了对多线程编程的支持，提供了丰富的多线程类和库，方便开发者编写多线程应用，实现并发和并行的任务执行。
8. 安全性：Java通过提供安全管理器和安全性特性，可以实现对Java程序的安全控制，防止恶意代码的执行和数据的篡改。

## 解释关于 JVM JDK 和 JRE

\
JVM、JDK和JRE是与Java开发和运行环境相关的术语，它们的含义如下：

1. JVM（Java Virtual Machine）：Java虚拟机是Java程序运行的核心组件。它是一个虚拟的计算机，负责解释和执行Java字节码（编译后的Java代码）。JVM在不同的操作系统上提供了一个统一的运行环境，实现了Java的平台无关性。
2. JDK（Java Development Kit）：Java开发工具包是Java开发人员用于开发和编译Java应用程序的集合。它包括了JVM、编译器（javac）、调试器（jdb）、工具和类库等。JDK提供了开发Java应用所需的一切工具和资源。
3. JRE（Java Runtime Environment）：Java运行时环境是在计算机上执行Java程序所需的最小环境。它包括了JVM和Java类库，但不包含开发工具（如编译器）。JRE只用于运行Java程序，而无法进行Java应用程序的开发。

简而言之，JDK是用于Java应用程序的开发工具包，包括了JVM和编译器等工具；JRE是用于运行Java应用程序的运行时环境，包括了JVM和Java类库；而JVM是虚拟机，负责解释和执行Java字节码。在开发Java应用程序时，需要安装JDK；在仅运行Java应用程序时，只需要安装JRE。

## Java的基本数据类型

请见下面的表格，其中列出了Java的基本数据类型及其包装器类型、存储空间大小和其他相关信息：

| 基本数据类型  | 包装器类型     | 存储空间     | 取值范围                                                   | 默认值      |
| ------- | --------- | -------- | ------------------------------------------------------ | -------- |
| boolean | Boolean   | 1位       | true或false                                             | false    |
| byte    | Byte      | 8位（1字节）  | -128 到 127                                             | 0        |
| short   | Short     | 16位（2字节） | -32,768 到 32,767                                       | 0        |
| int     | Integer   | 32位（4字节） | -2,147,483,648 到 2,147,483,647                         | 0        |
| long    | Long      | 64位（8字节） | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | 0L       |
| float   | Float     | 32位（4字节） | IEEE 754浮点数范围                                          | 0.0f     |
| double  | Double    | 64位（8字节） | IEEE 754浮点数范围                                          | 0.0      |
| char    | Character | 16位（2字节） | 0 到 65,535（Unicode编码）                                  | '\u0000' |

以上是Java的基本数据类型及其包装器类型，每个类型都有其对应的存储空间大小和取值范围。另外，这些基本数据类型的默认值在声明变量但未赋值时会被自动初始化。

## 聊一聊-JAVA 泛型中的通配符 T，E，K，V？

{% embed url="https://juejin.cn/post/6844903917835419661" %}

## ==和equals的区别？

"==" 操作符：比较的是引用的地址。

区别：

&#x20;     比较基本数据类型时：比较的是值是否相同；&#x20;

&#x20;     比较引用类型时：比较的是引用是否相同；

"equals()" 方法：比较的是对象的内容。

## hashCode()与 equals()

hashCode() 和 equals() 都是 Java 中的方法，它们都是用来比较两个对象是否相等的。

hashCode() 方法：用来计算对象的哈希码。通过对象中各个属性的值计算出一个整数。

哈希码是用来在散列存储器中定位对象的。如果两个对象的哈希码相同，则它们在散列存储器中的位置也相同，因此它们可以被看作是相等的。

equals() 方法：用来比较两个对象的内容是否相等。它是在 Java 语言中定义的一个方法，用来比较两个对象的属性是否相同。当两个对象的属性都相同时，equals() 方法返回 true ；当两个对象的属性不相同时，equals() 方法返回 false 。

在 Java 中，如果两个对象的类型不同，使用 == 运算符来比较它们是否相等会返回 false 。因此，在比较两个对象是否相等时，应该使用 equals() 方法而不是使用 == 运算符。另外，在比较两个对象是否相等时，应该同时比较它们的哈希码和内容，以确保它们真正地相等。

## 为什么重写equals方法时必须重写 hashCode方法？

在Java中，当我们重写一个类的`equals()`方法时，通常也需要同时重写`hashCode()`方法。这是因为在使用哈希表等数据结构时，对象的`hashCode()`方法被用于确定对象在内存中的存储位置和查找的快速性。

哈希表是基于哈希值进行存储和查找的数据结构，它通过将对象的哈希值映射到内存中的某个位置来快速定位对象。在使用哈希表时，首先会根据对象的哈希值确定其存储位置，然后再根据`equals()`方法判断具体的对象是否匹配。

如果我们重写了`equals()`方法，但没有重写`hashCode()`方法，可能会导致以下问题：

1. 不一致的结果：如果两个对象通过`equals()`方法被判断为相等，但它们的哈希值却不一样，那么它们在哈希表中的存储位置将不同，无法正常进行查找。
2. 违反哈希表的使用规则：根据Java规范，如果两个对象通过`equals()`方法返回相等，那么它们的哈希值必须相等。否则，在使用哈希表时可能会导致数据结构的异常行为，如无法正确查找对象或无法正确删除对象等。

因此，为了保持对象的一致性和正确性，在重写`equals()`方法时，我们需要同时重写`hashCode()`方法，以确保对象的相等性与哈希值的一致性。这样可以保证对象在使用哈希表等数据结构时能够正常存储和查找。

## 为什么Java只有值传递？

Java 中只有值传递是因为它的内存管理机制。在 Java 中，对象是使用垃圾回收机制来管理内存的。当一个对象不再被使用时，它不会被立即释放，而是会被放入一个内存池中，等待以后被再次使用。如果此时将一个对象作为参数传递给另一个方法，那么在方法调用时，对象的引用被传递给了方法，而对象本身并没有被传递。&#x20;

因此，当方法调用完成后，对象仍然存在于内存池中，等待被再次使用。如果此时将对象作为参数传递给另一个方法，那么会出现“引用传递”的问题，即传递的是对象的引用，而不是对象本身。这样，就会导致两个方法都引用同一个对象，从而造成内存泄漏。

为了避免这种情况的发生，Java 采用了只有值传递的方式，即在方法调用时，将对象的值复制一份传递给方法，而不是将对象本身传递。这样，即使方法调用完成后，对象不再被使用，也不会影响其他方法对该对象的使用。这种方式虽然会带来一定的性能损失，但是却能有效地避免内存泄漏的问题。

## 重载和重写

|      | 重载（Overloading）                   | 重写（Overriding）           |
| ---- | --------------------------------- | ------------------------ |
| 定义位置 | 同一个类中                             | 子类中对父类方法的重新定义            |
| 方法名  | 相同                                | 相同                       |
| 参数列表 | 不同的方法可以有不同的参数列表组合，包括参数类型、个数或顺序的差异 | 必须与父类方法的参数列表完全相同         |
| 返回类型 | 可以相同也可以不同                         | 必须相同                     |
| 动态绑定 | 静态绑定，根据方法签名（参数类型和个数）来确定调用哪个方法     | 动态绑定，根据对象的实际类型来确定调用哪个方法  |
| 调用方式 | 根据传入的参数类型和个数来选择合适的方法进行调用          | 根据对象的实际类型来确定调用哪个方法       |
| 继承关系 | 可以发生在同一个类中的不同方法，也可以发生在父类和子类之间     | 发生在子类中对父类方法的重新定义         |
| 目的   | 提供多种不同的方法，根据参数的差异选择合适的方法进行调用      | 在子类中改变父类方法的行为，以适应子类自身的需求 |

需要注意的是，重写是通过继承关系实现的，子类继承父类的方法并对其进行重新定义；而重载是在同一个类中定义多个同名的方法，但它们的参数列表有所不同。通过重写和重载，可以实现多态性和方法的灵活使用。

## 深拷贝和浅拷贝

在 Java 中，对象的拷贝有两种方式，即深拷贝和浅拷贝。&#x20;

深拷贝是将对象进行完全拷贝，创建一个新的对象。在深拷贝中，对于对象中的每个属性，都会创建一个新的对象，而不是使用原有的属性值。因此，深拷贝可以保证两个对象互不影响，即使其中一个对象发生改变，另一个对象仍然保持原有的状态。深拷贝通常用于需要保护对象不受外界影响的情况。

浅拷贝是将对象进行简单的拷贝，创建一个新的对象。在浅拷贝中，对于对象中的每个属性，都会使用原有的属性值，而不是创建一个新的对象。因此，浅拷贝不能保证两个对象互不影响，即使其中一个对象发生改变，另一个对象也会受到影响。浅拷贝通常用于需要快速创建对象的情况。&#x20;

需要注意的是，由于深拷贝需要创建新的对象，因此会比浅拷贝消耗更多的时间和内存。因此，在实际应用中，应该根据具体情况选择使用深拷贝还是浅拷贝。

## 接⼝和抽象类的区别

Java 中的接口和抽象类都是用来定义规范和约束的，但是它们有着不同的用途和实现方式。&#x20;

接口是一种特殊的抽象类，它里面只能包含抽象方法和常量，不能包含实例变量和实例方法。接口不能被实例化，只能被实现。接口的实现类必须实现接口中的所有抽象方法，否则就必须声明为抽象类。接口可以被多个类实现，这些类必须实现接口中的所有抽象方法。&#x20;

抽象类是一种普通的类，它可以包含抽象方法、实例变量和实例方法。抽象类可以被实例化，但是建议不要实例化它。抽象类可以包含非抽象方法，这些方法可以被实现。抽象类可以被多个类继承，这些类可以选择实现抽象类中的抽象方法，也可以选择不实现它们。

接口和抽象类的主要区别在于：

* 接口中只能包含抽象方法和常量，不能包含实例变量和实例方法；抽象类中可以包含抽象方法、实例变量和实例方法。
* 接口不能被实例化，只能被实现；抽象类可以被实例化，但是建议不要实例化它。
* 接口的实现类必须实现接口中的所有抽象方法，否则就必须声明为抽象类；抽象类的子类可以选择实现抽象类中的抽象方法，也可以选择不实现它们。

需要注意的是，虽然接口和抽象类都是用来定义规范和约束的，但是它们的用途和实现方式是不同的。在实际应用中，应该根据具体情况选择使用接口还是抽象类。

## String、StringBuffer和StringBuilder的区别是什么?

| 类型            | 可变性  | 线程安全性 | 性能 |
| ------------- | ---- | ----- | -- |
| String        | 不可变的 | 线程安全  | 低  |
| StringBuffer  | 可变的  | 线程安全  | 中  |
| StringBuilder | 可变的  | 非线程安全 | 高  |

希望这个表格能够更清晰地展示它们之间的区别。&#x20;

## String 为什么是不可变？

Java 中的 String 类是不可变的，这是因为它是由 final 关键字修饰的。

在 Java 中，final 关键字用来修饰类、方法和变量，表示它们是不可变的。当一个类被声明为 final 时，就不能被继承，也不能被修改；当一个方法被声明为 final 时，就不能被重写；当一个变量被声明为 final 时，就不能被修改。

<pre class="language-java"><code class="lang-java">public final class String implements Serializable, Comparable&#x3C;String>, CharSequence {
    @Stable
    private final byte[] value;
    ...    
<strong>}
</strong></code></pre>

## Arraylist 与 LinkedList 区别?

1. 是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；
2. 底层数据结构： Arraylist 底层使⽤的是 Object 数组； LinkedList 底层使⽤的是双向链表数据结构。
3. 插⼊和删除是否受元素位置的影响：&#x20;
   * ArrayList 采⽤数组存储，所以插⼊和删除元素的时间复杂度受元素位置的影响。 ⽐如：执⾏ add(E e) ⽅法的时候， ArrayList 会默认在 将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插⼊和删除元素的话（ add(int index, E element) ）时间复杂度就为 O(n-i)。因为在进 ⾏上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执⾏向后位/向前移⼀位的 操作。&#x20;
   * LinkedList 采⽤链表存储，所以对于 add(E e) ⽅法的插⼊，删除元素时间复杂 度不受元素位置的影响，近似 O(1)，如果是要在指定位置 i 插⼊和删除元素的话（ (add(int index, E element) ） 时间复杂度近似为 o(n)) 因为需要先移动到指定位置再插⼊。
4. 是否⽀持快速随机访问： LinkedList 不⽀持⾼效的随机元素访问，⽽ ArrayList ⽀持。 快速随机访问就是通过元素的序号快速获取元素对象(对应于 get(int index) ⽅法)。
5. 内存空间占⽤： ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留⼀定的容量空间，⽽ LinkedList 的空间花费则体现在它的每⼀个元素都需要消耗⽐ ArrayList 更多的空间 （因为要存放直接后继和直接前驱以及数据）。

## HashMap

{% embed url="https://angela.blog.csdn.net/article/details/104889549" %}

