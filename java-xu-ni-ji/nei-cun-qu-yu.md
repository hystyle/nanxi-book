---
description: 从Java 内存区域开始吧！
---

# 内存区域

## 聊一聊JVM内存区域

通常我们说到Java虚拟机（JVM）中的内存区域，主要分为以下几个部分：堆、虚拟机栈、本地方法栈、程序计数器、方法区。

* 方法区（Method Area）：用于存储类的结构信息、常量、静态变量等。在HotSpot虚拟机中，方法区被实现为永久代（Permanent Generation）。
* 堆（Heap）：堆是JVM中最大的一块内存区域，用于存储对象实例和数组。堆是被所有线程共享的，是垃圾回收的主要区域。
* 虚拟机栈（VM Stack）：每个线程都会有一个独立的栈，用于存储局部变量、方法调用和返回值等。栈是线程私有的，每个方法在执行时都会创建一个栈帧，方法执行结束后栈帧会被销毁。栈是一个后进先出（LIFO）的数据结构。
* 本地方法栈（Native Method Stack）：本地方法栈与虚拟机栈类似。用于存储Native方法的调用和执行信息。本地方法栈也是线程私有的。
* 程序计数器（Program Counter）：用于存储当前线程执行的字节码指令地址。程序计数器也是线程私有的，每个线程都有自己独立的程序计数器。

在Java SE 8之后，JVM的内存区域发生了一些改变。其中最主要的变化是：

1. 方法区被替换为元空间（Metaspace）：元空间仍然用于存储类的元数据信息，但是不再位于JVM的堆区域中，而是使用本地内存。这样可以提供更大的空间，不再受到默认堆大小的限制。元空间的大小可以根据需要进行动态调整，避免了传统方法区的内存溢出问题。
2. 永久代被移除：永久代是Java SE 8之前方法区的一种实现方式，用于存储类的元数据。由于永久代经常发生内存溢出的问题，并且难以进行有效的垃圾回收，Java SE 8将其移除，并引入了元空间作为替代。

总结一下，Java SE 8之前的JVM内存区域包括方法区、堆、栈、程序计数器和本地方法栈，而Java SE 8之后的版本中，方法区被替换为元空间（Metaspace），永久代被移除。这些变化主要是为了提供更大的元数据空间，并改善内存管理的性能和稳定性。

## 方法区和永久代、元空间的关系

方法区和永久代以及元空间的关系类似于Java 中接口和类的关系。

方法区可以看作是接口，而永久代和元空间可以看作是实现接口的类。也就是说永久代和元空间是

HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。

永久代是 JDK 1.8 之前的方法区实现，元空间是JDK 1.8 及以后方法区的实现。

## 对象的创建过程

1. 类加载：在Java程序中使用一个类之前，需要先将该类的字节码加载到内存中。类的加载包括加载、验证、准备和解析等步骤。类加载器根据类的全限定名查找并加载类的字节码。
2. 分配内存：在类加载完成后，需要在堆内存中为对象分配内存空间。Java的堆是所有对象实例的存储区域，动态分配内存是通过垃圾回收来实现的。
3. 初始化零值：在分配内存后，JVM会将对象的内存空间初始化为零值，包括基本类型的零值和引用类型的空引用。
4. 设置对象头：对象头是用于存储对象自身的运行时数据的一部分，包括对象的哈希码、锁信息和垃圾回收标记等。JVM会设置适当的对象头数据。
5. 执行构造函数：在对象头设置完成后，JVM会调用对象的构造函数进行对象的初始化。构造函数会对对象的成员变量进行初始化，可以进行一些额外的操作。
6. 对象初始化：在构造函数执行完成后，对象就完成了初始化，可以使用了。此时，对象的成员变量都已经赋予了正确的初始值。

