---
description: 从垃圾回收机制的基本原理开始吧！
---

# 垃圾回收机制

## 垃圾回收机制工作的基本原理

垃圾回收机制工作的基本原理是通过追踪对象的引用关系，确定哪些对象是可达的（被引用），哪些是不可达的（垃圾）。一旦对象变为不可达，垃圾回收器就会将其标记为可回收对象。

垃圾回收机制使用了"引用"的概念来判断对象的可达性。在Java中，存在四种类型的引用：

1. 强引用（Strong Reference）：使用最常见的引用类型，如果一个对象具有强引用，即使内存紧张，垃圾回收器也不会回收它。只有当没有任何强引用指向一个对象时，该对象才会成为垃圾的候选对象。
2. 软引用（Soft Reference）：用来描述一些还有用但非必需的对象。在内存不足时，垃圾回收器可以回收软引用对象。软引用通常用于实现内存敏感的缓存。
3. 弱引用（Weak Reference）：用于描述非必需的对象。如果一个对象只具有弱引用，那么当垃圾回收器进行垃圾回收时，无论内存是否充足，该对象都会被回收。
4. 虚引用（Phantom Reference）：也称为幽灵引用或幻影引用，它们唯一的作用是在对象被回收时接收一个系统通知。虚引用本身并不会影响对象的可达性，它通常与ReferenceQueue一起使用。

总的来说，垃圾回收机制通过判断对象的可达性来决定哪些对象是可以回收的，从而释放内存并提供自动的内存管理。这样可以减少程序员手动释放内存的工作，提高代码的可靠性和开发效率。

## **哪些对象可以作为 GC Roots**&#x20;

根对象是指在Java程序中被明确地引用的对象，它们通常存在于以下几个地方：

1. 方法区（Method Area）中的类静态变量（static fields）：这些变量是在类定义中使用static关键字声明的，它们属于类本身而不是实例对象。静态变量在整个程序运行期间都存在，作为根对象可以直接或间接引用其他对象。
2. 虚拟机栈（VM Stack）中的局部变量（Local Variables）：每个线程都有自己的虚拟机栈，用于存储方法的调用信息和局部变量。局部变量可以引用堆中的对象，因此它们也是根对象。
3. 本地方法栈（Native Method Stack）中的局部变量：本地方法栈用于执行本地方法（Native Method）的调用，本地方法是使用其他语言（如C或C++）编写的方法。本地方法栈中的局部变量也可以引用堆中的对象。
4. 寄存器（Registers）和常量引用（Constant References）：寄存器是处理器内部的存储空间，常量引用是指被声明为final的常量。这些寄存器和常量引用可以直接引用堆中的对象。

除了上述常见的GC Root内容，还有一些特殊情况下的GC Root，例如：

* 虚拟机内部的引导类加载器（Bootstrap Class Loader）：引导类加载器负责加载核心Java类，它被认为是GC Root。
* 虚拟机内部的JNI引用：JNI本身可能维护一些特殊的引用关系，这些引用也可以作为GC Root。

需要注意的是，GC Roots并不是一个具体的对象，而是一组对象，它们作为起点来判断其他对象的可达性。GC Roots对象本身可以是强引用、软引用、弱引用或虚引用。

垃圾回收器通过从GC Roots对象开始，追踪和标记其他可达对象，以确定哪些对象是可达的，哪些对象是垃圾。这样，不可达的对象将被判定为垃圾，可以被回收，而可达的对象将保留在内存中，继续被使用。

## 垃圾回收算法

垃圾回收算法分为：标记-清除（Mark and Sweep）、复制（Copying）、标记-整理（Mark and Compact）。

1. 标记-清除（Mark and Sweep）算法：

* 标记阶段：垃圾回收器从根对象开始，遍历所有可达对象，并将其标记为活动对象。
* 清除阶段：垃圾回收器扫描整个堆，将没有标记的对象认定为垃圾对象，并回收它们所占用的内存。
* 特点：标记-清除算法简单直观，适用于处理非连续内存的垃圾回收。但它会产生内存碎片，导致内存利用率降低，并且清除阶段的效率可能较低。

2. 复制（Copying）算法：

* 将堆空间划分为两个大小相等的区域，称为From区和To区。
* 当From区中的对象需要回收时，垃圾回收器将活动对象复制到To区，同时压缩对象，使它们紧凑排列。
* 完成复制后，From区中没有被复制的对象就成为垃圾，整个From区被一次性清空。
* 特点：复制算法避免了内存碎片的产生，而且清除阶段非常高效，只需要简单地将整个区域清空。但它会浪费一半的内存空间，因为To区只能使用一半的空间。

3. 标记-整理（Mark and Compact）算法：

* 标记阶段：与标记-清除算法相同，标记所有可达对象。
* 整理阶段：垃圾回收器将活动对象向一端移动，然后清理边界以外的内存空间。
* 特点：标记-整理算法消除了内存碎片的问题，使得内存空间更加连续。相较于复制算法，它不浪费内存空间，但整理阶段可能较为耗时。

## 垃圾收集器

1. Serial收集器：

* 单线程收集器，使用简单而高效的“标记-复制”算法。
* 适用于单核处理器或小型应用，对于小型内存和低延迟的环境有较好的表现。

2. Parallel收集器：

* 多线程收集器，在新生代使用“标记-复制”算法，在老年代使用“标记-清除-整理”算法。
* 适用于拥有多个CPU核心的服务器环境，能够充分利用多核CPU提高垃圾收集效率。

3. CMS（Concurrent Mark Sweep）收集器：

* 以最短的停顿时间为目标，并发标记和并发清除。
* 适用于对响应时间有较高要求的应用，减少垃圾收集阶段对应用线程的影响。

4. G1（Garbage-First）收集器：

* 并发和并行的垃圾收集器，将堆内存划分为多个区域，通过分代收集和部分压缩来优化垃圾回收。
* 适用于大内存应用和低延迟要求高的应用，能够在可控的停顿时间内实现高吞吐量的垃圾收集。

除了上述常见的垃圾收集器，还有一些特定场景下的收集器，如ZGC（Z Garbage Collector）和Shenandoah等。这些收集器在大内存和超低停顿时间的需求下具有出色的性能。&#x20;

选择合适的垃圾收集器应根据应用的需求和硬件环境来决定。对于小型应用或对延迟要求不高的应用，Serial收集器是一个简单且高效的选择。Parallel收集器适用于需要充分利用多核CPU的服务器环境。CMS收集器适合对响应时间要求较高的应用。而G1收集器则适用于大型内存和低延迟的应用。

## G1收集器的工作原理

G1（Garbage-First）收集器是Java虚拟机提供的一种并发、分代的垃圾收集器。它的工作原理如下：

1. 分区划分：

* G1将整个Java堆划分为多个大小相等的区域（Region）。
* 每个区域可以是Eden区、Survivor区或Old区。

2. 初始标记（Initial Mark）：

* G1收集器会暂停所有应用线程，执行一次初始标记，标记出GC Root直接关联的对象。
* 初始标记过程是并发执行的，尽量减少停顿时间。

3. 并发标记（Concurrent Mark）：

* G1开始并发标记阶段，在这个阶段中，垃圾收集器从根对象出发，通过可达性分析，标记所有存活的对象。
* 并发标记和应用线程同时执行，减少停顿时间。

4. 最终标记（Final Mark）：

* G1在并发标记完成后，会暂停应用线程，执行最终标记。
* 最终标记会处理在并发标记阶段有更新的对象，并标记被遗漏的存活对象。

5. 筛选回收（Live Data Counting）：

* G1收集器基于当前回收周期中存活对象的信息，计算每个区域中的存活对象数量。
* 根据存活对象数量和用户期望的垃圾回收时间，选择需要回收的区域。

6. 复制与清理（Copying and Cleaning）：

* G1将选定的区域进行复制，并清理掉非存活对象。
* 复制过程将存活对象复制到未使用的区域，并建立新的对象引用。

7. 空闲区域合并（Region Coalescing）：

* G1收集器会将连续的未使用区域合并成更大的区域，减少内存碎片化。

通过将堆内存划分为多个区域，G1收集器可以更加精确地控制和调整垃圾回收的范围和时间，从而避免全局垃圾回收带来的长时间停顿。G1收集器的目标是在可控的停顿时间内实现高吞吐量的垃圾收集，适用于大内存和低延迟要求的应用场景。&#x20;

需要注意的是，G1收集器的具体行为和配置可以根据应用的需求进行调优和调整，以达到最佳的性能和垃圾回收效果。

