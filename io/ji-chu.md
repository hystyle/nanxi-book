---
description: 从认识IO开始吧！
---

# 基础

## JAVA IO是什么

Java IO（输入/输出）是 Java 编程语言中用于读取和写入数据的标准库。它提供了一套丰富的类和接口，用于处理不同类型的数据输入和输出，包括文件、网络流、内存流等。

Java IO 主要涉及两个方面：输入和输出。

输入（Input）：输入是指从外部读取数据到程序中。Java IO 提供了用于读取数据的类和接口，例如 `InputStream`、`Reader` 等。这些类和接口可以从文件、网络连接、键盘输入等来源读取数据，并将其转换为程序可以处理的格式。

输出（Output）：输出是指将程序中的数据写入到外部设备或媒体中。Java IO 提供了用于写入数据的类和接口，例如 `OutputStream`、`Writer` 等。这些类和接口可以将数据以不同的形式写入到文件、网络连接、屏幕显示等目标中。

Java IO 提供了多种读写数据的方式，包括字节流和字符流。字节流（Byte Stream）用于处理二进制数据，而字符流（Character Stream）用于处理文本数据。Java IO 还提供了缓冲区、过滤器等机制，以提高读写效率和功能扩展。

## 为什么要区分为字节流和字符流

区分字节流和字符流是因为数据在计算机中以字节（byte）为单位存储和传输，而在应用程序中处理的数据往往是以字符（character）为单位的。

字节流（Byte Stream）以字节为基本单位进行读写操作，适用于处理二进制数据，例如图像、音频、视频等。字节流能够准确地传输和保存数据的每个字节，适用于对数据进行原始处理和传输。字节流主要涉及 `InputStream` 和 `OutputStream` 类及其子类。

字符流（Character Stream）以字符为基本单位进行读写操作，适用于处理文本数据，例如文本文件、配置文件、字符数据流等。字符流在读写数据时会自动进行字符编码和解码，能够处理多语言字符集和字符的特殊处理需求。字符流主要涉及 `Reader` 和 `Writer` 类及其子类。

区分字节流和字符流的主要原因是为了处理不同类型的数据。使用字节流可以更直接地处理二进制数据，而字符流则提供了更高级、更方便的处理文本数据的方法。字符流在读写时会自动进行字符编码和解码，能够处理不同字符集的数据，提供了更方便的文本处理功能，如字符缓冲、字符编码转换等。

此外，字符流的使用也能够提高跨平台的兼容性。由于不同操作系统对于文本文件的编码方式可能不同，使用字符流进行读写可以在不同平台上保持一致的文本处理结果。

因此，根据数据的性质和处理需求，我们选择适合的字节流或字符流来进行数据的读写操作，以便更好地处理和操作不同类型的数据。

## 在Java中字节流和字符流常用的类分别有哪些

在Java中，字节流和字符流都有一些常用的类和接口。以下是它们的一些常见代表：

字节流（Byte Stream）：

* `InputStream`：字节输入流的抽象类，提供了读取字节的基本方法。
* `FileInputStream`：用于从文件中读取字节的类。
* `ByteArrayInputStream`：用于从字节数组中读取字节的类。
* `FilterInputStream`：过滤器字节输入流的抽象类，提供了对其他字节输入流进行包装并提供附加功能的能力。
* `DataInputStream`：用于以基本数据类型读取字节的类。
* `OutputStream`：字节输出流的抽象类，提供了写入字节的基本方法。
* `FileOutputStream`：用于向文件中写入字节的类。
* `ByteArrayOutputStream`：用于将字节写入字节数组的类。
* `FilterOutputStream`：过滤器字节输出流的抽象类，提供了对其他字节输出流进行包装并提供附加功能的能力。
* `DataOutputStream`：用于以基本数据类型写入字节的类。

字符流（Character Stream）：

* `Reader`：字符输入流的抽象类，提供了读取字符的基本方法。
* `FileReader`：用于从文件中读取字符的类。
* `BufferedReader`：用于带有缓冲的字符输入，提供了更高效的字符读取方法。
* `InputStreamReader`：将字节输入流转换为字符输入流的桥接类。
* `StringReader`：从字符串中读取字符的类。
* `Writer`：字符输出流的抽象类，提供了写入字符的基本方法。
* `FileWriter`：用于向文件中写入字符的类。
* `BufferedWriter`：用于带有缓冲的字符输出，提供了更高效的字符写入方法。
* `OutputStreamWriter`：将字节输出流转换为字符输出流的桥接类。
* `StringWriter`：向字符串中写入字符的类。

这些类和接口提供了丰富的功能和方法，用于在Java中进行字节和字符的读写操作。根据具体的需求和场景，选择合适的类和接口进行数据的输入和输出。

## Java中常见的IO模型有哪些

在Java中，常见的IO模型主要包括以下几种：

1. 同步阻塞IO模型（Blocking IO）：也称为传统的IO模型或阻塞IO模型。在该模型下，当程序执行IO操作时，线程会阻塞等待直到数据就绪才能继续执行。这是一种单线程处理IO的模型，适用于连接数较少、每个连接并发性要求不高的场景。
2. 同步非阻塞IO模型（Non-blocking IO）：也称为同步异步IO模型。在该模型下，IO操作仍然是同步的，但是在数据未就绪时，不会阻塞线程，而是通过轮询或者选择器等方式来检查数据是否就绪，从而实现非阻塞的特性。这种模型适用于连接数较多、但每个连接并发性要求不高的场景。
3. 多路复用IO模型（Multiplexed IO）：通过使用操作系统提供的多路复用机制，如epoll、select等，实现了一个线程处理多个IO操作的能力。在该模型下，一个线程可以同时监听多个通道的IO事件，当有IO事件发生时，通过非阻塞方式处理，提高了并发处理能力。
4. 异步IO模型（Asynchronous IO）：也称为事件驱动IO模型。在该模型下，IO操作是异步的，不需要应用程序主动等待数据的就绪，而是通过回调函数或者Future/Promise等机制来处理已经就绪的数据。这种模型适用于高并发、高吞吐量的场景。

Java提供了多种IO类和相关的API来支持不同的IO模型，如传统的阻塞IO可以使用`InputStream`和`OutputStream`等类，非阻塞IO可以使用`SocketChannel`和`ServerSocketChannel`等类，多路复用IO可以使用`Selector`类，而异步IO可以使用`AsynchronousSocketChannel`和`AsynchronousFileChannel`等类。

## 详解IO多路复用

I/O多路复用（I/O Multiplexing）是一种高效的网络编程模型，它允许一个进程同时监听多个I/O事件，从而提高程序的并发处理能力。在I/O多路复用模型中，一个线程可以监视多个文件描述符（通常是网络套接字），并在有事件发生时进行处理。

I/O多路复用程序通常使用以下的关键组件：

1. 文件描述符集合（File Descriptor Set）：程序需要创建一个文件描述符集合，用于存储要监听的I/O事件。这可以是一个数组或者其他数据结构。
2. I/O复用函数（I/O Multiplexing Function）：程序使用I/O复用函数，如select()、poll()或epoll()，将文件描述符集合注册到内核中，并进行事件监听。
3. 事件处理（Event Handling）：当I/O事件发生时，I/O复用函数会返回，程序可以通过遍历文件描述符集合来确定哪些文件描述符上有事件发生。然后，程序可以根据具体的事件类型进行相应的处理，如接受连接、读取数据或发送数据等。

I/O多路复用模型的优点在于它可以同时处理多个I/O事件，而不需要为每个事件创建一个独立的线程。这样可以减少线程的创建和销毁开销，提高系统的并发性能和资源利用率。

常见的I/O多路复用函数有：

* select()：是传统的I/O多路复用函数，支持最大文件描述符数量的限制。
* poll()：是对select()的改进，没有最大文件描述符数量的限制。
* epoll()：是Linux特有的I/O多路复用函数，具有高性能和可扩展性。

需要注意的是，I/O多路复用模型需要结合非阻塞I/O（Non-blocking I/O）或异步I/O（Asynchronous I/O）才能发挥其最大的效果。通过将文件描述符设置为非阻塞模式，可以确保在没有I/O事件发生时不会阻塞线程，从而提高程序的并发处理能力。&#x20;

总之，I/O多路复用程序是一种高效的网络编程模型，可以实现高并发的I/O操作。它适用于需要同时处理多个I/O事件的场景，如服务器程序中的并发连接处理、事件驱动的系统和高性能网络应用等。

## epoll()的优势

`epoll()` 是 Linux 操作系统提供的一种高效的 IO 多路复用机制，它相比于传统的 `select()` 和 `poll()` 具有以下几个优势：

1. 支持大规模的并发连接：`epoll()` 使用了红黑树（RB-Tree）数据结构来管理文件描述符，可以高效地处理大规模的并发连接，不会随着连接数的增加而性能下降。
2. 高效的事件通知机制：`epoll()` 通过回调机制，在发生 IO 事件时直接通知应用程序，避免了轮询和遍历所有文件描述符的开销。这样可以更快地响应和处理就绪的 IO 事件。
3. 零拷贝技术：`epoll()` 支持通过 `splice()` 和 `sendfile()` 等系统调用实现零拷贝技术。零拷贝可以减少数据从内核缓冲区到用户缓冲区的拷贝次数，提高数据传输效率。
4. 更低的系统开销：`epoll()` 采用事件驱动的方式，只有在发生 IO 事件时才会通知应用程序，避免了不必要的系统开销。相比于 `select()` 和 `poll()`，`epoll()` 在大量连接的场景下表现更好。

综上所述，`epoll()` 在处理大规模并发连接时具有较高的性能，并且支持高效的事件通知、零拷贝技术和较低的系统开销，因此在高性能网络编程中被广泛使用。

